import random

from Crypto.Util.number import long_to_bytes, bytes_to_long

# Pick someone else's signature and verify it.
# Brandon Cox
n = 4158916957612766447474168715164891699510585970427508784080581469019932450298517109458013894081618959643692134259246526352142717678152956188314948129195210874108302490441854126286145653184315893786564926567618013107012406596892504747640985476306138497348076276619092445010138731986179413279842921077381890342021240784205933225307665219376261672428436014685895802815110443794496838676573802775486660409068125138052464183760446650441814510318136844162733413494735997421533487481979141891230620413611059557006718035001198006753663260643906721439054693463225188268525333046731964583592331638538303615779016208787063610493778842425399286824072477760588097197971520622351832117533804314876045629819432870867978767125382376797115458879578603042691843855608217282138610882566735926100874754076206780264836920851658220531348202361739711036329994873414782976992623990162750895160884363055513974408726829631945204059798061913574986193803
e = 65537
signature = 436070718808317300746249604216598378984020949881359922586440097431390725294136203375312323938259401805184913873441549793558480337911277011883445094526189906831951687676031392822849456776733515953902352972245953868650341606355516169535826547198784468584431671198402178633083011352601314762643639479204549236403668930793420998803912525166071823331337841988851991199912165205837708537443368915343829054896983095440519474801701412951389294410696368976443913224302460613289856178327199369904195424725375925554956842384620850974764322171265574779921235805932762203024509335624200100531283479937472300754330024654033251725588435310182493104250584692948315364865268670912393654858519553317163361066407055667158683548038078227678301314733756322157666137791428923361572877791429219982540375160288069909352744372773296163625856679040961450549885279207255938896381857653440717749281238115121322870732526067064898791732571757633566295262
check = pow(signature, e, n)
decryption = long_to_bytes(check)
print(decryption.decode('utf-8'))

'''
Gibberish Signature: Now, take someone's public key, and generate a random "fake signature" (any random number σ′∈ℤ∗n) then reverse a message m′:=σ′emodn. Now if you publish m′,σ′ we will verify that the person who published that public key signed your gibberish message too. 
'''
# fake  Signature
fake = random.randrange(signature)
print('signature_fake = ', fake)
decryption = pow(fake, e, n)
print('m_fake = ', long_to_bytes(decryption))

'''
Find a "factorization" of a message: Take the message: 
"I, the undersigned, do solemnly swear to pick boogers, eat them, and wipe any excess on my shirt." 
Convert it to an integer, m. 
Now take your own public-key, n, and pick a random number m1∈ℤ∗n. 
Compute an m2 such that m1⋅m2 is the malicious message. 
Now sign the two noise messages m1,m2 and confirm that their product 
is your own signature on the the booger message.
'''
# INCOMPLETE
# My own
msg = b', the undersigned, do solemnly swear to pick boogers, eat them, and wipe any excess on my shirt.'
msg_as_int = bytes_to_long(msg)
n = 21141691271572177742869718056193017415749330583752621936915331000952019930790241097100440887274217871042703926570520679560523074057106815248463302994193595744707670483434533731694328047863401375277834771334687308738302417357352784457546846863788579009620446321139563584044856521128039226549266390171904992056357781509758860416106814201580160723283328838750375528545565333296416333750271110266901442579158124953359437572416158716934838917834899371483982586974853599733795056972287284374761911081122786712584151910494437730754021573395898734797869532716916048751381002890393866736414235301718959017130112241709277472821
private_exponent = '669a44392bebcb73f7c391c58e641af24088c2ac157670ed3350ab55fc621b9c0e1b3e05189d216e21fcf47216792e63c0680539610858829c8d390e9ef695daf998f52e1afb4c0a48693369e249ca7ca4ad80500e5b3a93caac010f76909bef371d433beda1ba24e789999f2d69ad35ee4b6948fa22c7471834374335f4b71da327d3921e541bf746b09617bf303fa70b0d119fb40216075bf0b53bc94ae96d926fd1908eda7cd0615da4988d164244fdc174cc02621f71acc62f71d1b8e00392f52956cd563a3777f249e522f4a7587519a4e62eeeae5506e8b60f1fbe33d58fd73e9309f4708fa44505a198990a29c85600da1c39a799327d20930db2c1c1'
d = int(private_exponent, 16)
signature = pow(msg_as_int, d, n)

m1 = random.randrange(msg_as_int)
m2 = int(signature / m1)
print(m2)


# m1
m1_signed = pow(m1, d, n)
m2_signed = pow(m2, d, n)
print(m1*m2 == signature)
print(signature - (m1*m2))
